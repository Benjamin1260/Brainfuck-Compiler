main(/T2): #entry
# init
- init msg_queue2
- create T1 (msg_queue2, fileName)
- wait for *msg_queue1

- create T3 (msg_queue1, *buff)
- wait for *msg_queue3
- assign *msg_queue3 to var

#assembler
- wait for T1
- assemble from ptr
- send ptr to MC to T3
- repeat assembler
//end


T1: (msg_queue2, fileName)
#init
- init msg_queue1
- send *msg_queue1 to T2

#setup
- open file
- load contents
- close file

#compilation
- create buffer
- convert BF to asm
- find adequate endpoint
- send ptr of buffer to T2
- repeat compilation
//end


T3: (msg_queue1, *buff)
#init
- init msg_queue3
- store *msg_queue3 in *buff
- send rdy measage to T2

#execution  //we execute a part of the code, then halt till we get a new msg
- wait for T2
- jmp to IP parsed in msg
- <execute>
- repeat execution
//end


T1 > main(T2) > T3 > T1

all jmp labels, meaning loops and at intermediate ends should have their values
stored in memory so that these can be overriden later, this is necessary for:
-   the intermediate stops of machine code, our code might stop in the middle of a loop,
    when the code hasn't been compiled, we should jump to code that makes the thread halt,
    but after the subsequent code has been finished, the jump adress should be overriden to
    said code.

-   maybe we have two jmpTables, one for loopstarts and loopends and one for linkink the end
    of one section to the beginning of the next

"jmp loop1" -> "jmp 16(jmpListLoop)"
"jmp sect1" -> "jmp 8(jmpListSec)"

what happens when at runtime our list runs out of space?
this is something the compiler should deal with, it should create
a new table and reset it's element counter